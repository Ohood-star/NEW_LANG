/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. MyNewGrammar.jj */
/*@egen*//**
 * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+
 */
options
{
  static = true;
}

PARSER_BEGIN(MyNewGrammar)
package black_Candy_jjt;

public class MyNewGrammar/*@bgen(jjtree)*/implements MyNewGrammarTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTMyNewGrammarState jjtree = new JJTMyNewGrammarState();

/*@egen*/

  public static void main(String args []) throws ParseException
  {System.out.println("BLACK Candy programming language  \ud83d\udda4");//Welcome to our language for users
    System.out.print("Enter:"); //Here the user will enter the sentence to follow the rules of the BLACK Candy language
    new MyNewGrammar(System.in);
     try
    {
      SimpleNode n= MyNewGrammar.start();
      n.dump(">>"); 
      MyNewGrammar.start();
      System.out.println("ACCEPTED \n Thank you \ud83d\udc8b. :)");  //it will print it to user if her/him follow the rules correctly
    }
    catch (Exception e)
    {
      System.out.println("Oops.\n NOT ACCEPTED :( ");  //it will print it to user if her/him do some thing wrong
      System.out.println(e.getMessage());
    }
  }
}
    
PARSER_END(MyNewGrammar)


//                                     **** TOKENS ****

//Here we will review the BLACK Candy language TOKENS in addition to their meanings

SKIP :  // this "SKIP"  it will do skipping for a lots of thing
{
 < spaces : " " >  // do SKIP for spaces
| "\r"        // & do SKIP  for  Carriage return
| "\t"          // & do SKIP  for Horizontal tab
| "\n"           // & do SKIP  for New line
| < Comment : "%%" (~["\n"])* >
  // & do SKIP  for Comment ,it that mean if her/him do   Comment  ,It begins with %%then will put her/him Comment 
}

// ----------------------------------------

TOKEN : /* Arithmetic operation */
{
  < PLUS : "&" >    // It's PLUS      TOKEN looks .
| < MINUS : "*&" >    // It's   MINUS     TOKEN looks.
| < MULTIPLY : "X" >   // It's  MULTIPLY      TOKEN looks .
| < DIVIDE : "*X" >  // It's  DIVIDE      TOKEN  looks.
}

// ----------------------------------------

TOKEN : /* Relational operation */
{
  < EQUALS : "~~" >   // It's  EQUALS      TOKEN  looks.
| < NOT_EQUALS : "*~~" >// It's  NOT EQUALS      TOKEN looks.
}

// ----------------------------------------

TOKEN : /*  Comparison */
{
  < GRATER_THAN : "~*" >  // It's  GRATER_THAN     TOKEN  looks.
| < LESS_THAN : "*~" >  // It's   LESS_THAN   TOKEN looks.
}

// ----------------------------------------

TOKEN : /* Logical operator */
{
< OR : "v" >     // It's    OR     TOKEN looks.
| < AND : "^" >    // It's  AND     TOKEN

}

// ----------------------------------------

TOKEN: { /*Alphabet, DIGIT */
  < Alphabet :  (["a"-"z", "A"-"Z" ]) >  // our Alphabet start from "A" to "Z" like Capital letter and Small letter
| < DIGIT : (["0"-"9"]) >   // our DIGIT start from "0" to "9"
|  < OZ : (["0"-"1"]) >    // our binary number  is "0" and "1"
}

// ----------------------------------------
 
TOKEN: { /* IDENTIFIRES */ 
  < ID : "#" (<Alphabet>){2,10 } "#">  // To   Define any variable should start with "#" and end with "#"
}

// ----------------------------------------

TOKEN: { /* Punctuation Marks */
  < COLON : "," >
| < UPCOLON : "'" > 
| < DOT : "." >
| < DOTS : ":" > 
| < HASH : "#" >  //IDENTIFIRES Should start with # and end with it 
| < VER : "||" >
| < EX : "!" >
| < AT : "@" >   //Keyword Should start with @


}

// ----------------------------------------

TOKEN: { /*Assign operator  */
  < ASSIGN : "->" >  // to  Assign  any statment 
}

// ----------------------------------------

TOKEN : /* Digits */ {
   < DOUBLE : (<DIGIT>)+ < DOT >(<DIGIT>)+ >
   | < INT : (<DIGIT>)+ >
 }

// ----------------------------------------

TOKEN: { /* KEYWORD */
  < ARRAY : "Array">
| < num : "num"> // integer  number 
| < NUM : "NUM">  //double number 
| < SEN : "sen">   // string 
| < MAIN : "main">  // Main class 
| < WRITE : "write">  // to print 
| < CON : "CON">       // for a CONDITION
| < word : "word"> // for a  word 
}

// ----------------------------------------

TOKEN: { /* word */
  < WORD : (<Alphabet>)(<Alphabet>)+>    // The word consists of two or more letters
}

// ----------------------------------------

TOKEN: { /* STRING */
  < STRING : (< WORD >)(" "(<WORD>))* > //The STRING consists of one  or more word or space 
}



//                                     **** BNF ****


// ----------------------------------------                               
 SimpleNode start (): {/*@bgen(jjtree) start */
                       SimpleNode jjtn000 = new SimpleNode(JJTSTART);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; }
 {/*@bgen(jjtree) start */
 try {
/*@egen*/
 STMT() t= < DOT > {jjtn000.jjtSetValue(t.image);}/*@bgen(jjtree)*/
 {
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
 }
/*@egen*/
 {
   return jjtn000;
 }/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

// ----------------------------------------

void STMT(): {/*@bgen(jjtree) STMT */
              SimpleNode jjtn000 = new SimpleNode(JJTSTMT);
              boolean jjtc000 = true;
              jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}
{/*@bgen(jjtree) STMT */
   try {
/*@egen*/
   LOOKAHEAD(2)
 
  ASSIGMNET()|  ARRAY()  |CONDITION()| (Numbers() ( ARTHIMETIC()| LogicalOperator() | Comparisons()  |RelationalOperator() ))/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
 }

// ----------------------------------------

 void ASSIGMNET(): {/*@bgen(jjtree) ASSIGMNET */
                    SimpleNode jjtn000 = new SimpleNode(JJTASSIGMNET);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/Token t1,t2;}     //this method  Know any   DATA_TYPE  and ASSIGMNET  then  print Its type 
  {/*@bgen(jjtree) ASSIGMNET */
 try {
/*@egen*/ 
 t1=  < AT > 
  DATA_TYPE()
  IDEN()
  t2= < ASSIGN >  
   (VAR())/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {jjtn000.jjtSetValue(t1.image+", "+t2.image);}/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/ 
}

// ----------------------------------------

 void IDEN(): {/*@bgen(jjtree) IDEN */
                SimpleNode jjtn000 = new SimpleNode(JJTIDEN);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }     //this method  Know  ID  then  print Its type 
  {/*@bgen(jjtree) IDEN */
 try {
/*@egen*/ 
 t= < ID >/*@bgen(jjtree)*/
           {
             jjtree.closeNodeScope(jjtn000, true);
             jjtc000 = false;
           }
/*@egen*/ {jjtn000.jjtSetValue(t.image);}/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

// ----------------------------------------

void VAR(): {/*@bgen(jjtree) VAR */
             SimpleNode jjtn000 = new SimpleNode(JJTVAR);
             boolean jjtc000 = true;
             jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}      //this method  Know   VARbales  then  print Its type 
{/*@bgen(jjtree) VAR */
 try {
/*@egen*/
 ( Numbers() |  t=< WORD >/*@bgen(jjtree)*/
                           {
                             jjtree.closeNodeScope(jjtn000, true);
                             jjtc000 = false;
                           }
/*@egen*/ {jjtn000.jjtSetValue(t.image);}| t=< STRING >/*@bgen(jjtree)*/
                                                                        {
                                                                          jjtree.closeNodeScope(jjtn000, true);
                                                                          jjtc000 = false;
                                                                        }
/*@egen*/{jjtn000.jjtSetValue(t.image);})/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/ 
}

// ----------------------------------------

void INDEXend(): {/*@bgen(jjtree) INDEXend */
                  SimpleNode jjtn000 = new SimpleNode(JJTINDEXEND);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/Token t1, t2;}      //this method  Know  INDEXend for array   then  print it
{/*@bgen(jjtree) INDEXend */
 try {
/*@egen*/
 (t1=< DOT > t2=<EX >)/*@bgen(jjtree)*/
                      {
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                      }
/*@egen*/{jjtn000.jjtSetValue(t1.image+", "+t2.image);}/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

// ----------------------------------------

void ArrrayElements(): {/*@bgen(jjtree) ArrrayElements */
                        SimpleNode jjtn000 = new SimpleNode(JJTARRRAYELEMENTS);
                        boolean jjtc000 = true;
                        jjtree.openNodeScope(jjtn000);
/*@egen*/Token t;}    //this method  Know  ArrrayElements and  print it by type 
{/*@bgen(jjtree) ArrrayElements */
 try {
/*@egen*/
 (t=< WORD >/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
            }
/*@egen*/{jjtn000.jjtSetValue(t.image);} |t=< INT >/*@bgen(jjtree)*/
                                                      {
                                                        jjtree.closeNodeScope(jjtn000, true);
                                                        jjtc000 = false;
                                                      }
/*@egen*/{jjtn000.jjtSetValue(t.image);})/*@bgen(jjtree)*/
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/  
}

// ----------------------------------------

void ARRAY(): {/*@bgen(jjtree) ARRAY */
               SimpleNode jjtn000 = new SimpleNode(JJTARRAY);
               boolean jjtc000 = true;
               jjtree.openNodeScope(jjtn000);
/*@egen*/Token t1,t2,t3,t4, t5; }  //this method  Know  Arrray and  print  array's components
{/*@bgen(jjtree) ARRAY */
   try {
/*@egen*/
   t1= < AT >
   t2=  < ARRAY >
   IDEN()
   t3= <ASSIGN >
   (t4= <VER>)
   (ArrrayElements() INDEXend())+
   (t5= <VER>)/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   {jjtn000.jjtSetValue(t1.image+", "+t2.image+ " , "+t3.image+", "+t4.image+", "+t5.image);}/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
     }
   }
/*@egen*/
}

// ----------------------------------------

void DATA_TYPE(): {/*@bgen(jjtree) DATA_TYPE */
                    SimpleNode jjtn000 = new SimpleNode(JJTDATA_TYPE);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t;}    //this method  Know  DATA_TYPE and  print it by type 

{/*@bgen(jjtree) DATA_TYPE */
try {
/*@egen*/
 
(   t= < num >/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/ {jjtn000.jjtSetValue(t.image);}
| t= < NUM >/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/ {jjtn000.jjtSetValue(t.image);}
| t= < SEN >/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/ {jjtn000.jjtSetValue(t.image);}
| t= < CON >/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/ {jjtn000.jjtSetValue(t.image);}
| t= < word >/*@bgen(jjtree)*/
              {
                jjtree.closeNodeScope(jjtn000, true);
                jjtc000 = false;
              }
/*@egen*/ {jjtn000.jjtSetValue(t.image);}
)/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
  }
}
/*@egen*/
}

// ----------------------------------------

void Numbers(): {/*@bgen(jjtree) Numbers */
                  SimpleNode jjtn000 = new SimpleNode(JJTNUMBERS);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; } //this method  Know  DATA_TYPE and  print it by type 
 {/*@bgen(jjtree) Numbers */
    try {
/*@egen*/
    ( t= < INT >/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ {jjtn000.jjtSetValue(t.image);}  | t= < DOUBLE >/*@bgen(jjtree)*/
                                                                  {
                                                                    jjtree.closeNodeScope(jjtn000, true);
                                                                    jjtc000 = false;
                                                                  }
/*@egen*/ {jjtn000.jjtSetValue(t.image);} )/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
 }

// ----------------------------------------
 void ARTHIMETIC(): {/*@bgen(jjtree) ARTHIMETIC */
                     SimpleNode jjtn000 = new SimpleNode(JJTARTHIMETIC);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; }
 {/*@bgen(jjtree) ARTHIMETIC */
    try {
/*@egen*/
    (  t= < PLUS > {jjtn000.jjtSetValue(t.image);}| t= < MINUS > {jjtn000.jjtSetValue(t.image);}| t= < MULTIPLY > {jjtn000.jjtSetValue(t.image);}| t= < DIVIDE > {jjtn000.jjtSetValue(t.image);}) Numbers()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
 }
 
// ----------------------------------------

void Comparisons(): {/*@bgen(jjtree) Comparisons */
                     SimpleNode jjtn000 = new SimpleNode(JJTCOMPARISONS);
                     boolean jjtc000 = true;
                     jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; }
{/*@bgen(jjtree) Comparisons */
 try {
/*@egen*/
 (t= < GRATER_THAN > {jjtn000.jjtSetValue(t.image);}| t= < LESS_THAN >  {jjtn000.jjtSetValue(t.image);}) Numbers()/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

// ----------------------------------------

void LogicalOperator(): {/*@bgen(jjtree) LogicalOperator */
                          SimpleNode jjtn000 = new SimpleNode(JJTLOGICALOPERATOR);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) LogicalOperator */
 try {
/*@egen*/
 (t= < OR > {jjtn000.jjtSetValue(t.image);}| t= < AND > {jjtn000.jjtSetValue(t.image);})  Numbers()/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

// ----------------------------------------

void RelationalOperator(): {/*@bgen(jjtree) RelationalOperator */
                             SimpleNode jjtn000 = new SimpleNode(JJTRELATIONALOPERATOR);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t;}
{/*@bgen(jjtree) RelationalOperator */
 try {
/*@egen*/
 ( t= < EQUALS > {jjtn000.jjtSetValue(t.image);}| t= < NOT_EQUALS > {jjtn000.jjtSetValue(t.image);} ) Numbers()/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

// ----------------------------------------

void CONDITION(): {/*@bgen(jjtree) CONDITION */
                    SimpleNode jjtn000 = new SimpleNode(JJTCONDITION);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t1,t2,t3,t4;}
{/*@bgen(jjtree) CONDITION */
  try {
/*@egen*/
  (t1= < DOTS >
   t2= < DOTS > )
  Numbers() (Comparisons() | LogicalOperator () |RelationalOperator ())
  (t3=< DOTS >
   t4=< DOTS >)
   CON()/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
   }
/*@egen*/
   {jjtn000.jjtSetValue(t1.image+", "+t2.image+ " , "+t3.image+", "+t4.image);}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

// ----------------------------------------

void CON(): {/*@bgen(jjtree) CON */
             SimpleNode jjtn000 = new SimpleNode(JJTCON);
             boolean jjtc000 = true;
             jjtree.openNodeScope(jjtn000);
/*@egen*/Token t1,t2,t3; }
{/*@bgen(jjtree) CON */
  try {
/*@egen*/
  LOOKAHEAD(2)
 
 (t1= < DOTS >  {jjtn000.jjtSetValue(t1.image);})*  
 (Numbers() ( Comparisons() | LogicalOperator () |RelationalOperator ()) t2= < DOTS > t3=<DOTS > {jjtn000.jjtSetValue(t2.image+ " , "+t3.image);} STMT())  
| STMT()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/


}